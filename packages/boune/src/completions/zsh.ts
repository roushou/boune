import type { CliConfig, CommandConfig, InternalOptionDef } from "../types/index.ts";

/**
 * Generate zsh completion script for a CLI
 */
export function generateZshCompletion(config: CliConfig): string {
  const name = config.name;
  const funcName = `_${name.replace(/-/g, "_")}`;

  const lines: string[] = [
    "#compdef " + name,
    "",
    `# Zsh completion for ${name}`,
    `# Generated by boune`,
    "",
    `${funcName}() {`,
    '    local curcontext="$curcontext" state line',
    "    typeset -A opt_args",
    "",
    "    _arguments -C \\",
  ];

  // Add global options
  const globalOpts = config.globalOptions.filter((o) => !["help", "version"].includes(o.name));
  lines.push("        '(- *)'{-h,--help}'[Show help]' \\");

  if (config.version) {
    lines.push("        '(- *)'{-V,--version}'[Show version]' \\");
  }

  for (const option of globalOpts) {
    lines.push(`        ${formatZshOption(option)} \\`);
  }

  // Get visible commands
  const commands = getVisibleCommands(config.commands);

  if (commands.length > 0) {
    lines.push("        '1: :->command' \\");
    lines.push("        '*:: :->args'");
    lines.push("");
    lines.push("    case $state in");
    lines.push("        command)");
    lines.push("            local -a commands");
    lines.push("            commands=(");

    for (const cmd of commands) {
      const desc = cmd.description.replace(/'/g, "'\\''");
      lines.push(`                '${cmd.name}:${desc}'`);
    }

    lines.push("            )");
    lines.push("            _describe 'command' commands");
    lines.push("            ;;");
    lines.push("        args)");
    lines.push("            case $line[1] in");

    for (const cmd of commands) {
      lines.push(...generateZshCommandCase(cmd, "                "));
    }

    lines.push("            esac");
    lines.push("            ;;");
    lines.push("    esac");
  } else {
    // Remove trailing backslash from last option
    const lastIdx = lines.length - 1;
    lines[lastIdx] = lines[lastIdx]!.replace(/ \\$/, "");
  }

  lines.push("}");
  lines.push("");
  lines.push(`${funcName} "$@"`);
  lines.push("");

  return lines.join("\n");
}

function formatZshOption(option: InternalOptionDef): string {
  const desc = (option.description || "")
    .replace(/'/g, "'\\''")
    .replace(/\[/g, "\\[")
    .replace(/\]/g, "\\]");
  const takesArg = option.type !== "boolean";

  const longFlag = option.long ?? option.name;

  if (option.short) {
    if (takesArg) {
      return `'(-${option.short} --${longFlag})'{-${option.short},--${longFlag}}'[${desc}]:value'`;
    }
    return `'(-${option.short} --${longFlag})'{-${option.short},--${longFlag}}'[${desc}]'`;
  }

  if (takesArg) {
    return `'--${longFlag}[${desc}]:value'`;
  }
  return `'--${longFlag}[${desc}]'`;
}

function getVisibleCommands(commands: Record<string, CommandConfig>): CommandConfig[] {
  const seen = new Set<CommandConfig>();
  const result: CommandConfig[] = [];

  for (const config of Object.values(commands)) {
    if (!seen.has(config) && !config.hidden) {
      seen.add(config);
      result.push(config);
    }
  }

  return result;
}

function generateZshCommandCase(command: CommandConfig, indent: string): string[] {
  const lines: string[] = [];
  const subcommands = getVisibleCommands(command.subcommands);

  lines.push(`${indent}${command.name})`);

  if (subcommands.length > 0) {
    lines.push(`${indent}    _arguments -C \\`);
    lines.push(`${indent}        '(- *)--help[Show help]' \\`);

    for (const option of command.options) {
      lines.push(`${indent}        ${formatZshOption(option)} \\`);
    }

    lines.push(`${indent}        '1: :->subcmd' \\`);
    lines.push(`${indent}        '*:: :->args'`);
    lines.push(`${indent}    case $state in`);
    lines.push(`${indent}        subcmd)`);
    lines.push(`${indent}            local -a subcommands`);
    lines.push(`${indent}            subcommands=(`);

    for (const sub of subcommands) {
      const desc = sub.description.replace(/'/g, "'\\''");
      lines.push(`${indent}                '${sub.name}:${desc}'`);
    }

    lines.push(`${indent}            )`);
    lines.push(`${indent}            _describe 'subcommand' subcommands`);
    lines.push(`${indent}            ;;`);
    lines.push(`${indent}        args)`);
    lines.push(`${indent}            case $line[1] in`);

    for (const sub of subcommands) {
      lines.push(`${indent}                ${sub.name})`);
      lines.push(`${indent}                    _arguments \\`);
      lines.push(`${indent}                        '(- *)--help[Show help]' \\`);
      for (const option of sub.options) {
        lines.push(`${indent}                        ${formatZshOption(option)} \\`);
      }
      // Remove trailing backslash from last line
      const lastIdx = lines.length - 1;
      lines[lastIdx] = lines[lastIdx]!.replace(/ \\$/, "");
      lines.push(`${indent}                    ;;`);
    }

    lines.push(`${indent}            esac`);
    lines.push(`${indent}            ;;`);
    lines.push(`${indent}    esac`);
  } else {
    lines.push(`${indent}    _arguments \\`);
    lines.push(`${indent}        '(- *)--help[Show help]' \\`);

    for (const option of command.options) {
      lines.push(`${indent}        ${formatZshOption(option)} \\`);
    }

    // Remove trailing backslash from last line
    const lastIdx = lines.length - 1;
    lines[lastIdx] = lines[lastIdx]!.replace(/ \\$/, "");
  }

  lines.push(`${indent}    ;;`);

  return lines;
}
